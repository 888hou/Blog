`TypeScript` 的核心原则之一是对值所具有的结构进行类型检查。我们使用接口（`Interfaces`）来定义对象的类型。**接口是对象的状态(属性)和行为(方法)的抽象(描述)**

## 1. 接口描述对象类型

我们可以使用接口来定义对象的类型，下面通过一个简单示例来观察接口是如何描述对象类型的。

假设有这样一个需求: 创建一个人的对象, 需要对人的属性进行一定的约束

```
id是number类型, 必须有, 只读的
name是string类型, 必须有
age是number类型, 必须有
sex是string类型, 可以没有
```

那么，描述这个人的对象的接口如下：

```typescript
// 定义人的接口
interface IPerson {
  id: number;
  name: string;
  age: number;
  sex: string;
}
```

有了这个接口以后，当我们在定义这个人的对象时，类型检查器就会查看对象内部的属性是否与 IPerson 接口描述一致, 如果不一致就会提示类型错误。如下：

```typescript
// 正确
const person1: IPerson = {
  id: 1,
  name: "tom",
  age: 20,
  sex: "男",
};

// age 类型有误
const person2: IPerson = {
  id: 1,
  name: "tom",
  age: "20",
  sex: "男",
};
```

![](~@/typescript/02/01.png)

### 1.1 可选属性

有时候，接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。我们把这种属性称之为「可选属性」。带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 `?` 符号。可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。

当我们把属性 `sex` 设置为可选属性后，我们在定义对象时，如果没有属性 `sex` ，此时编辑器不会报错。如下：

```typescript
interface IPerson {
  id: number;
  name: string;
  age: number;
  sex?: string;
}

const person2: IPerson = {
  id: 1,
  name: "tom",
  age: 20,
  // sex: '男' // 可以没有
};
```

### 1.2 只读属性

有些对象属性只能在对象创建的时候赋值，一旦赋值后再也不允许修改了，对于这种属性我们称之为「只读属性」 你可以在属性名前用 `readonly` 来指定标识哪个属性为只读属性。

当我们将属性 `id` 指定为只读属性时，再之后如果想要修改该属性，编辑器就会报错，如下：

![](~@/typescript/02/02.png)

### 1.3 readonly vs const

最简单判断该用 `readonly` 还是 `const` 的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 `const`，若做为属性则使用 `readonly`。

## 2. 接口描述函数类型

接口能够描述 `JavaScript` 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。

为了使用接口表示函数类型，我们需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。

```typescript
/* 
接口可以描述函数类型(参数的类型与返回的类型)
*/

interface SearchFunc {
  (source: string, subString: string): boolean;
}
```

这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。

```typescript
const mySearch: SearchFunc = function(source: string, sub: string): boolean {
  return source.search(sub) > -1;
};

console.log(mySearch("abcd", "bc"));
```

## 3. 接口描述类类型

### 3.1 类实现接口

与 `C#` 或 `Java` 里接口的基本作用一样，`TypeScript` 也能够用它来明确的强制一个类去符合某种契约。

```typescript
/* 
类类型: 实现接口
1. 一个类可以实现多个接口
2. 一个接口可以继承多个接口
*/

interface Alarm {
  alert(): any;
}

interface Light {
  lightOn(): void;
  lightOff(): void;
}

class Car implements Alarm {
  alert() {
    console.log("Car alert");
  }
}
```

### 3.2 一个类可以实现多个接口

```typescript
class Car2 implements Alarm, Light {
  alert() {
    console.log("Car alert");
  }
  lightOn() {
    console.log("Car light on");
  }
  lightOff() {
    console.log("Car light off");
  }
}
```

## 4. 接口继承

和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。

假设有这样一个需求：除了上述我们定义的人的对象的接口之外，我们还需要定义程序员和警察这两个对象的接口，这两个对象的属性与人的对象属性基本相同，只是有个别属性不同，为了防止代码的重复，此时我们便可以利用接口的继承来实现，如下：

```typescript
interface IPerson {
  id: number;
  name: string;
  age: number;
  sex: string;
}

interface IProgrammer extends IPerson {
  workPlace: string;
}

interface IPolicemen extends IPerson {
  workPlace: string;
}
```
